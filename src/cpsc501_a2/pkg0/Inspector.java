/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package cpsc501_a2.pkg0;

import java.util.Vector;
import java.lang.reflect.*;

/**
 *
 * @author shshunda
 */
public class Inspector {
    /*
    Does this need a constructor? Perhaps
    some variables can be abstracted out.
    */
    
    public void inspect(Object obj, boolean recursive) {
        // Following Jordan Kidney's "ObjectInspector.java",
        // use a Vector as a data structure for storing objects
        Vector objectsToInspect = new Vector();
        
        // Create instance of a class object based on the method input
        // To be used for every subsequent introspection.
        Class classObject = obj.getClass();
        
        /*
         * Programming Plan, before applying any refactoring
         * or unit testing. Most of these are just library method calls.
         * Referencing the Java library: (java.lang.reflect)
         */
        // Name of the declaring class
        System.out.println("INSPECTING THE DECLARING CLASS");
        System.out.println("The declaring class is: " + getDeclaring(classObject));
        System.out.println("DONE INSPECTING THE DECLARING CLASS");
        
        // Name of the declaring superclass
            // Using refactoring of getting superclass.
        System.out.println("INSPECTING THE DECLARING CLASS");
        System.out.println("The declaring class is: " + getSuper(classObject));
        System.out.println("DONE INSPECTING THE DECLARING CLASS");
        
        /*
        * It is worth noting that at this stage, all of these
        * above snippets of code would refactor into void methods
        * with side-effects. I will have to declare a returning
        * type and then make a query to that method, and THEN
        * print it out. However, this is just a sequence of what
        * my program ought to be doing at this stage.
        */
                
        // At this point, it was not possible to automatically
        // refactor these into methods with return values.
        // Began manual refactoring.
        
        // Methods the class declares
        // Exceptions
        // Parameter types
        // Return type
        // Modifiers
        // Constructors the class declares
        // Type
        // Modifiers
        // Current value of each field. If recursive == false, print
        // out the reference value.        
        
    }
    
    // Refactoring library method for getting
    // a declaring class into constituent wrapper.
    public String getDeclaring(Class x) {
        Class declaring = x.getDeclaringClass();
        String declaringReturn = declaring.toString();
        return declaringReturn;
    }
    
    // Refactoring interface library methods for
    // getting the superclass of an object.
    public String getSuper(Class x) {
        Class superClass = x.getSuperclass();
        String superReturn = superClass.toString();
        return superReturn;
    }
    
    // At this point, unit tests are required.
    // Autogenerated using IDE.
    
    // Since getting the interfaces of a class is entailed
    // by traversing an array containing elements of type Class,
    // two methods will be required. The first will traverse 
    // the array, and the second will be a wrapper which
    // returns strings of those Class elements.
    // There might be a way to get this into one form.
    public Class[] getClassInterfaces(Class[] x) {
        // Name of the interfaces the class implements
        Class classObject = x.getClass();
        Class[] classInterfaces = classObject.getInterfaces();
        return classInterfaces;
        // Since the interfaces are returned in an array,
        // traverse it.
        // In this case, we are only asked for the name, although
        // it is possible to retrieve other data about the interfaec
        // after each iteration.
    }
    
    // What I can do here instead is return the Class[] object,
    // and then create a loop which queries the above method.
    // This would return individual Class objects, which can 
    // then be cast to Strings. This is what I will be testing.
        // This would be an advanced refactoring, using:
    /*         if (classInterfaces.length > 0) {
            System.out.println("INSPECTING THE CLASS INTERFACES");
            for (Class classInterface : classInterfaces) {
                System.out.println("Interface: " + classInterface);
            }
            System.out.println("DONE INSPECTING THE CLASS INTERFACES");
        } 
    */
    // Going to save this for later, and instead test the getClassInterfaces
    // wrapper, obtained from "extract method" refactoring.
    
}
